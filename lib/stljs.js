// Generated by CoffeeScript 1.6.3
(function() {
    var Stl, child_proc, fs, path, stl_parser, to_image;

    fs = require('fs');

    path = require('path');

    child_proc = require('child_process');

    stl_parser = require('./parser/stl_parser');

    to_image = require('./to/image');

    Stl = (function() {
        function Stl() {}

        return Stl;

    })();

    Stl.readFile = function(filePath, callback, progressCb) {
        return stl_parser.parseFile(filePath, callback, progressCb);
    };

    Stl.parseFileContents = function(contentStream, callback, progressCb) {
        return stl_parser.parse(contentStream, callback, progressCb);
    };

    Stl.imageify = function(filePath, options, callback, progressCb) {
        if (options === null) {
            options = {};
        }
        if (options.width === null || typeof options.width === 'undefined') {
            options.width = 800;
        }
        if (options.height === null || typeof options.height === 'undefined') {
            options.height = 600;
        }
        return to_image.convertFile(filePath, options, callback, progressCb);
    };

    Stl.writeFile = function(fileName, solidName, polygons, callback) {
        var stream, writePolygon;
        stream = fs.createWriteStream(fileName);
        writePolygon = function(vertices, normal) {
            var vertex, _i, _len;
            stream.write("  facet normal " + normal.x + " " + normal.y + " " + normal.z + "\n");
            stream.write("    outer loop\n");
            for (_i = 0, _len = verticies.length; _i < _len; _i++) {
                vertex = verticies[_i];
                stream.write("      vertex " + vertex.pos.x + " " + vertex.pos.y + " " + vertex.pos.z + " \n");
            }
            stream.write("    endloop\n");
            return stream.write("  endfacet\n");
        };
        return stream.once('open', function(fd) {
            var normal, polygon, v, _i, _j, _len, _ref;
            stream.write("solid " + solidName + "\n");
            for (_i = 0, _len = polygons.length; _i < _len; _i++) {
                polygon = polygons[_i];
                normal = polygon.vertices[0].normal;
                for (v = _j = 1, _ref = polygon.verticies.length - 1; 1 <= _ref ? _j < _ref : _j > _ref; v = 1 <= _ref ? ++_j : --_j) {
                    writePolygon([polygon.vertices[0], polygon.vertices[v], polygon.vertices[v + 1]], normal);
                }
            }
            stream.write("endsolid " + solidName + "\n");
            if (callback) {
                return callback(null);
            }
        });
    };

    module.exports = Stl;

}).call(this);