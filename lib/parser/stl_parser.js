// Generated by CoffeeScript 1.6.3
(function() {
    var Stl, fs, _ref,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };

    fs = require('fs');

    Stl = (function() {
        function Stl() {}

        return Stl;

    })();

    Stl.Parser = (function() {
        function Parser() {
            this._reset();
        }

        Parser.prototype._reset = function() {
            this.normal = [];
            return this.verticies = [];
        };

        Parser.prototype.isBinaryFile = function(filePath) {
            var bytesRead, countBuf, fd, fileStat, predictedSize;
            countBuf = new Buffer(4);
            fd = fs.openSync(filePath, 'r');
            bytesRead = fs.readSync(fd, countBuf, 0, 4, 80);
            fs.closeSync(fd);
            predictedSize = 80 + 4 + 50 * countBuf.readUInt32LE(0);
            fileStat = fs.statSync(filePath);
            return predictedSize === fileStat.size;
        };

        Parser.prototype.isBinary = function(input, callback) {
            var isFirstData, predictedSize, totalLen;
            totalLen = 0;
            isFirstData = true;
            predictedSize = null;
            input.resume();
            input.on('data', function(data) {
                totalLen += data.length;
                if (isFirstData && totalLen > 84) {
                    predictedSize = 80 + 4 + 50 * data.readUInt32LE(80);
                    return isFirstData = false;
                }
            });
            input.on('end', function() {
                if (totalLen < 80) {
                    return callback(new Error("File is too short to be an STL file"));
                } else {
                    return callback(null, predictedSize === totalLen);
                }
            });
            return input.on('error', function(err) {
                return callback(err);
            });
        };

        Parser.prototype.parseFile = function(filePath, callback, progressCb) {
            var parser, readStream;
            readStream = fs.createReadStream(filePath);
            readStream.pause();
            if (this.isBinaryFile(filePath)) {
                parser = new Stl.BinaryParser();
            } else {
                parser = new Stl.AsciiParser();
            }
            return parser.parse(readStream, callback, progressCb);
        };

        Parser.prototype.parse = function(input, callback, progressCb) {

            input.pause();

            this.isBinary(input, function(err, isBinary) {
                var parser;

                if (err) {
                    return callback(err);
                }

                if (isBinary) {
                    parser = new Stl.BinaryParser();
                } else {
                    parser = new Stl.AsciiParser();
                }

                return parser.parse(input, callback, progressCb);

            });

        };

        return Parser;

    })();

    Stl.AsciiParser = (function(_super) {
        __extends(AsciiParser, _super);

        function AsciiParser() {
            _ref = AsciiParser.__super__.constructor.apply(this, arguments);
            return _ref;
        }

        AsciiParser.prototype._detectName = function(line) {
            var md;
            md = line.match(/^solid/);
            if (md != null) {
                md = line.match(/solid\s+(\w+)/);
                if (md != null) {
                    return md[1];
                } else {
                    return "_default_name_for_model";
                }
            } else {
                return null;
            }
        };

        AsciiParser.prototype.parse = function(input, callback, progressCb) {
            var modelName, solidModel,
                _this = this;
            solidModel = [];
            modelName = null;
            return this.eachLine(input, function(line) {
                var name;
                name = _this._detectName(line);
                if (name != null) {
                    modelName = name;
                }
                return _this.eachPolygon(line, function(err, polygon) {
                    if (err != null) {
                        callback(err);
                        return;
                    }
                    if ((progressCb != null) && !(typeof progressCb === 'undefined')) {
                        progressCb(null, polygon, modelName);
                    }
                    return solidModel.push(polygon);
                });
            }, function(err) {
                return callback(err, solidModel, modelName);
            });
        };

        AsciiParser.prototype.eachPolygon = function(line, callback) {
            var el, vertex;
            if (line.match(/facet normal/)) {
                el = line.split(/\s+/).filter(function(e) {
                    return e.length !== 0;
                });
                return this.normal = el.slice(2).map(function(e) {
                    return parseFloat(e);
                });
            } else if (line.match(/vertex/)) {
                el = line.split(/\s+/).filter(function(e) {
                    return e.length !== 0;
                });
                vertex = el.slice(1).map(function(e) {
                    return parseFloat(e);
                });
                return this.verticies.push(vertex);
            } else if (line.match(/endfacet/)) {
                callback(null, {
                    verticies: this.verticies,
                    normal: this.normal
                });
                return this._reset();
            }
        };

        AsciiParser.prototype.eachLine = function(input, iterator, callback) {
            var remaining,
                _this = this;
            if (typeof input === 'string') {
                input.split(/\n/).forEach(function(line) {
                    if (iterator != null) {
                        return iterator(line);
                    }
                });
                return callback(null);
            } else if (Buffer.isBuffer(input)) {
                console.log("haven't implemented buffer reading of ascii files");
                return callback(null);
            } else {
                remaining = '';
                input.on('data', function(data) {
                    var index, last, line;
                    remaining += data;
                    index = remaining.indexOf('\n');
                    last = 0;
                    while (index > -1) {
                        line = remaining.substring(last, index);
                        last = index + 1;
                        index = remaining.indexOf('\n', last);
                        iterator(line);
                    }
                    return remaining = remaining.substring(last, remaining.length);
                });
                input.on('end', function() {
                    if (remaining.length > 0) {
                        iterator(remaining);
                    }
                    return callback(null);
                });
                input.on('error', function(err) {
                    return callback(err);
                });
                return input.resume();
            }
        };

        return AsciiParser;

    })(Stl.Parser);

    Stl.BinaryParser = (function(_super) {
        var VECTOR_SIZE;

        __extends(BinaryParser, _super);

        VECTOR_SIZE = 3 * 4;

        function BinaryParser() {
            this.remainingBuf = null;
            this.remainingLen = 0;
        }

        BinaryParser.prototype.parse = function(input, callback, progressCb) {
            var header, isFirstData, modelName, solidModel, totalLen,
                _this = this;
            totalLen = 0;
            header = "";
            solidModel = [];
            modelName = null;
            isFirstData = true;
            input.on('data', function(data) {
                var triangleData;
                totalLen += data.length;
                if (isFirstData === true && totalLen > 84) {
                    header = data.toString('ascii', 0, 80);
                    modelName = header.replace(/\s+/g, '').replace(/\W+/g, '_');
                    isFirstData = false;
                    triangleData = data.slice(84);
                } else {
                    triangleData = data;
                }
                return _this.chunkData(triangleData, 50, function(chunkBuf) {
                    var attribute, normal, polygon, verticies;
                    normal = _this.readVector(chunkBuf, 0);
                    verticies = [_this.readVector(chunkBuf, VECTOR_SIZE), _this.readVector(chunkBuf, 2 * VECTOR_SIZE), _this.readVector(chunkBuf, 3 * VECTOR_SIZE)];
                    attribute = chunkBuf.readUInt16LE(4 * VECTOR_SIZE);
                    polygon = {
                        verticies: verticies,
                        normal: normal,
                        attribute: attribute
                    };
                    solidModel.push(polygon);
                    if ((progressCb != null) && !(typeof progressCb === 'undefined')) {
                        return progressCb(null, polygon, modelName);
                    }
                });
            });
            input.on('end', function() {
                return callback(null, solidModel, modelName);
            });
            input.on('error', function(err) {
                return callback(err);
            });
            return input.resume();
        };

        BinaryParser.prototype.readVector = function(buffer, offset) {
            var x, y, z;
            x = buffer.readFloatLE(offset);
            y = buffer.readFloatLE(offset + 4);
            z = buffer.readFloatLE(offset + 2 * 4);
            return [x, y, z];
        };

        BinaryParser.prototype.chunkData = function(buffer, numBytes, iterator) {
            var chunk, i, _results;
            i = 0;
            _results = [];
            while (i < buffer.length) {
                if ((i + numBytes) <= buffer.length) {
                    if (this.remainingBuf === null) {
                        chunk = buffer.slice(i, i + numBytes);
                        iterator(chunk);
                        _results.push(i += numBytes);
                    } else {
                        buffer.copy(this.remainingBuf, this.remainingLen, 0, numBytes - this.remainingLen);
                        iterator(this.remainingBuf);
                        i += numBytes - this.remainingLen;
                        this.remainingBuf = null;
                        _results.push(this.remainingLen = 0);
                    }
                } else {
                    this.remainingBuf = new Buffer(numBytes);
                    this.remainingBuf.fill(0);
                    this.remainingLen = buffer.length - i;
                    buffer.copy(this.remainingBuf, 0, i, buffer.length);
                    _results.push(i += this.remainingLen + 1);
                }
            }
            return _results;
        };

        return BinaryParser;

    })(Stl.Parser);

    module.exports = new Stl.Parser();

}).call(this);