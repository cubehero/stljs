// Generated by CoffeeScript 1.6.3
(function() {
  var Stl, fs, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require('fs');

  Stl = (function() {
    function Stl() {}

    return Stl;

  })();

  Stl.Parser = (function() {
    function Parser() {
      this._reset();
    }

    Parser.prototype._reset = function() {
      this.normal = [];
      return this.verticies = [];
    };

    Parser.prototype.isBinaryFile = function(filePath) {
      var bytesRead, countBuf, fd, fileStat, predictedSize;
      countBuf = new Buffer(4);
      fd = fs.openSync(filePath, 'r');
      bytesRead = fs.readSync(fd, countBuf, 0, 4, 80);
      fs.closeSync(fd);
      predictedSize = 80 + 4 + 50 * countBuf.readUInt32LE(0);
      fileStat = fs.statSync(filePath);
      return predictedSize === fileStat.size;
    };

    Parser.prototype.isBinary = function(input, callback) {
      var isFirstData, predictedSize, totalLen;
      totalLen = 0;
      isFirstData = true;
      predictedSize = null;
      input.resume();
      input.on('data', function(data) {
        totalLen += data.length;
        if (isFirstData && totalLen > 84) {
          predictedSize = 80 + 4 + 50 * data.readUInt32LE(80);
          return isFirstData = false;
        }
      });
      input.on('end', function() {
        if (totalLen < 80) {
          return callback(new Error("File is too short to be an STL file"));
        } else {
          return callback(null, predictedSize === totalLen);
        }
      });
      return input.on('error', function(err) {
        return callback(err);
      });
    };

    Parser.prototype.parseFile = function(filePath, callback, progressCb) {
      var parser, readStream;
      readStream = fs.createReadStream(filePath);
      readStream.pause();
      if (this.isBinaryFile(filePath)) {
        parser = new Stl.BinaryParser();
      } else {
        parser = new Stl.AsciiParser();
      }
      return parser.parse(readStream, callback, progressCb);
    };

    Parser.prototype.parse = function(input, callback, progressCb) {
      return console.log("not yet implemented naked parser");
    };

    return Parser;

  })();

  Stl.AsciiParser = (function(_super) {
    __extends(AsciiParser, _super);

    function AsciiParser() {
      _ref = AsciiParser.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    AsciiParser.prototype._detectName = function(line) {
      var md;
      md = line.match(/^solid/);
      if (md != null) {
        md = line.match(/solid\s+(\w+)/);
        if (md != null) {
          return md[1];
        } else {
          return "_default_name_for_model";
        }
      } else {
        return null;
      }
    };

    AsciiParser.prototype.parse = function(input, callback, progressCb) {
      var modelName, solidModel,
        _this = this;
      solidModel = [];
      modelName = null;
      return this.eachLine(input, function(line) {
        var name;
        name = _this._detectName(line);
        if (name != null) {
          modelName = name;
        }
        return _this.eachPolygon(line, function(err, polygon) {
          if (err != null) {
            callback(err);
            return;
          }
          if ((progressCb != null) && !(typeof progressCb === 'undefined')) {
            progressCb(null, polygon, modelName);
          }
          return solidModel.push(polygon);
        });
      }, function(err) {
        return callback(err, solidModel, modelName);
      });
    };

    AsciiParser.prototype.eachPolygon = function(line, callback) {
      var el, vertex;
      if (line.match(/facet normal/)) {
        el = line.split(/\s+/).filter(function(e) {
          return e.length !== 0;
        });
        return this.normal = el.slice(2).map(function(e) {
          return parseFloat(e);
        });
      } else if (line.match(/vertex/)) {
        el = line.split(/\s+/).filter(function(e) {
          return e.length !== 0;
        });
        vertex = el.slice(1).map(function(e) {
          return parseFloat(e);
        });
        return this.verticies.push(vertex);
      } else if (line.match(/endfacet/)) {
        callback(null, {
          verticies: this.verticies,
          normal: this.normal
        });
        return this._reset();
      }
    };

    AsciiParser.prototype.eachLine = function(input, iterator, callback) {
      var remaining,
        _this = this;
      if (typeof input === 'string') {
        input.split(/\n/).forEach(function(line) {
          if (iterator != null) {
            return iterator(line);
          }
        });
        return callback(null);
      } else if (Buffer.isBuffer(input)) {
        console.log("haven't implemented buffer reading of ascii files");
        return callback(null);
      } else {
        remaining = '';
        input.on('data', function(data) {
          var index, last, line;
          remaining += data;
          index = remaining.indexOf('\n');
          last = 0;
          while (index > -1) {
            line = remaining.substring(last, index);
            last = index + 1;
            index = remaining.indexOf('\n', last);
            iterator(line);
          }
          return remaining = remaining.substring(last, remaining.length);
        });
        input.on('end', function() {
          if (remaining.length > 0) {
            iterator(remaining);
          }
          return callback(null);
        });
        input.on('error', function(err) {
          return callback(err);
        });
        return input.resume();
      }
    };

    return AsciiParser;

  })(Stl.Parser);

  Stl.BinaryParser = (function(_super) {
    var VECTOR_SIZE;

    __extends(BinaryParser, _super);

    VECTOR_SIZE = 3 * 4;

    function BinaryParser() {
      this.remainingBuf = null;
      this.remainingLen = 0;
    }

    BinaryParser.prototype.parse = function(input, callback, progressCb) {
      var header, isFirstData, modelName, solidModel, totalLen,
        _this = this;
      totalLen = 0;
      header = "";
      solidModel = [];
      modelName = null;
      isFirstData = true;
      input.on('data', function(data) {
        var triangleData;
        totalLen += data.length;
        if (isFirstData === true && totalLen > 84) {
          header = data.toString('ascii', 0, 80);
          modelName = header.replace(/\s+/g, '').replace(/\W+/g, '_');
          isFirstData = false;
          triangleData = data.slice(84);
        } else {
          triangleData = data;
        }
        return _this.chunkData(triangleData, 50, function(chunkBuf) {
          var attribute, normal, polygon, verticies;
          normal = _this.readVector(chunkBuf, 0);
          verticies = [_this.readVector(chunkBuf, VECTOR_SIZE), _this.readVector(chunkBuf, 2 * VECTOR_SIZE), _this.readVector(chunkBuf, 3 * VECTOR_SIZE)];
          attribute = chunkBuf.readUInt16LE(4 * VECTOR_SIZE);
          polygon = {
            verticies: verticies,
            normal: normal,
            attribute: attribute
          };
          solidModel.push(polygon);
          if ((progressCb != null) && !(typeof progressCb === 'undefined')) {
            return progressCb(null, polygon, modelName);
          }
        });
      });
      input.on('end', function() {
        return callback(null, solidModel, modelName);
      });
      input.on('error', function(err) {
        return callback(err);
      });
      return input.resume();
    };

    BinaryParser.prototype.readVector = function(buffer, offset) {
      var x, y, z;
      x = buffer.readFloatLE(offset);
      y = buffer.readFloatLE(offset + 4);
      z = buffer.readFloatLE(offset + 2 * 4);
      return [x, y, z];
    };

    BinaryParser.prototype.chunkData = function(buffer, numBytes, iterator) {
      var chunk, i, _results;
      i = 0;
      _results = [];
      while (i < buffer.length) {
        if ((i + numBytes) <= buffer.length) {
          if (this.remainingBuf === null) {
            chunk = buffer.slice(i, i + numBytes);
            iterator(chunk);
            _results.push(i += numBytes);
          } else {
            buffer.copy(this.remainingBuf, this.remainingLen, 0, numBytes - this.remainingLen);
            iterator(this.remainingBuf);
            i += numBytes - this.remainingLen;
            this.remainingBuf = null;
            _results.push(this.remainingLen = 0);
          }
        } else {
          this.remainingBuf = new Buffer(numBytes);
          this.remainingBuf.fill(0);
          this.remainingLen = buffer.length - i;
          buffer.copy(this.remainingBuf, 0, i, buffer.length);
          _results.push(i += this.remainingLen + 1);
        }
      }
      return _results;
    };

    return BinaryParser;

  })(Stl.Parser);

  module.exports = new Stl.Parser();

}).call(this);
